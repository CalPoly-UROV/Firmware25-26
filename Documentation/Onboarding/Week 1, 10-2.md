## STMCubeIDE
#### Downloading the IDE for windows
[https://www.st.com/en/development-tools/stm32cubeide.html#st-get-software](https://www.st.com/en/development-tools/stm32cubeide.html#st-get-software)  

- Make an account
- Extract downloaded zip & run exe
- Only download STLINK Drivers
	- STLINK USB driver is required to upload code to microcontroller board, make sure you have this  

#### Making a Project  
- Start New STM32 Project
	- It takes a bit because it has to download library files for the microprocessor
- Target Selection : STM32F439ZI
- Project Setup
- ![Image](https://github.com/CalPoly-UROV/Firmware25-26/blob/main/Documentation/Onboarding/Week%201%20Images/Pasted%20image%2020251002194626.png)
	- Click Next
	- Check only "Copy only the necessary files"
	- Finish

#### Downloading Necessary Project Files
- Help -> STM32Cube updates -> Connection to myST
	- Then login to your ST account
- Open up the .ioc file in the project browser
- ![[Week 1 Images\Pasted image 20251002195014.png]]
- Generate Code

#### Code Generation
The IOC is a GUI abstraction that lets you easily configure all of the peripherals. What pins are on, what do they do, what kind of communication protocol to use, how long should a timer count, etc. When the IDE generates code, it takes all these settings and writes the C code that initializes and sets all these variables.  
![[Week 1 Images/Pasted image 20251002195700.png]]

#### main.c
Open `main.c` The file is split into multiple sections by comments, each section has a specific purpose you should follow. In some cases, code generation will mess with certain sections, so make sure you are writing in the correct section to not get your code overwritten

`int main(void){}`   
	This function will be ran when the MCU first powers on.    

`while(1){}`   
	This is an infinite loop, it will run continuously. Embedded systems programming is unique because it uses infinite loops. This is fine because we want the MCU to repeatedly do something over and over. For example, we want to keep checking if we've received commands from topside. If we received a command, do something, then return to waiting.

### Task 1: Blinky 
Goal : Make the dev board's LED blink on and off
##### 1. Enable the LED pin
The dev board has an LED we can turn on and off. It is connected to the MCU via a pin. To find this pin, read through the dev board's user manual 

Dev Board User Manual: https://github.com/CalPoly-UROV/Firmware25-26/blob/main/Documentation/Datasheets%20%26%20Ref%20Mans/nucleo-f439zi.pdf
- This type of document specifies features for the specific board : NUCLEO-F439ZI
- Green LED is connected to pin PB0
	Pin: An individual output
	Port: A collection of pins
	PB0 is the 0 pin in port B

Back in the IOC, set PB0 to GPIO_Output  
- GPIO : General Purpose Input/Output
![[Pasted image 20251003130622.png]]
Then save and generate code

#### 2. Program Functionality
Back in main.c
![[Pasted image 20251003130738.png]]
`MX_GPIO_Init()` was added by code generation. This function enables the pin and sets things up so it functions as a GPIO output.  
![[Pasted image 20251003132646.png]]
Add this code into the `while(1)` loop. 

#### 3. Upload Code to the Board  
Plug the board into your computer & press the green play button to build & run code.
![[Pasted image 20251003131303.png]]
Now the board's LED should be blinking.

### How does it work?  
Weâ€™ll look at this at a register-level

##### `GPIOB`
This is the port in which PB0 resides.  
-> means to get a member variable of a struct. So we are getting GPIOB's ODR

#### `ODR` Output Data Register
This is the register which holds the output data for port B.
Reference Manual : https://github.com/CalPoly-UROV/Firmware25-26/blob/main/Documentation/Datasheets%20%26%20Ref%20Mans/STM32F4_RefMan.pdf
![[Pasted image 20251003132959.png]]
The ODR is 16 bits long and each bit corresponds to the output of a pin.

#### `GPIOB->ODR ^ 1`: XOR the ODR with 1
1 in binary is `0000000000000001`  

Lets assume the ODR is currently empty: `0000000000000000`  

XOR takes in 2 bits and outputs 1 bit according to the truth table below  

| XOR | 1   | 0   |
| --- | --- | --- |
| 1   | 0   | 1   |
| 0   | 1   | 0   |
XOR'ing 2 binary values performs an XOR on each individual bit with its corresponding bit.  
`...0001 ^ ...0000 = ...0001`  So we write `0000000000000001` into ODR & PB0 outputs high.  

When the loop runs again, now the ODR is `...0001` So we perform`...0001 ^ ...0001 = ...0000` and write `0000000000000000` into ODR & PB0 outputs low.  

This cycle repeats and the LED toggles between on & off.  

#### Register Notes
Most registers are 32 bits long, but some like the ODR have the top 16 bits reserved. You cannot write individual bits of a register, you must write entire binary values to registers every time. Look up binary bit manipulation.

### Task 2: Button-LED 
There is a button on the dev board connected to a certain pin. 
1. Find out which pin the button is connected to (Check dev board user manual)
2. Find out if pressing the button makes the pin go from high to low or vice-versa
3. Configure that pin as an input in the IOC
4. Find the register which records the input of a pin
5. Write a program which toggles the LED on and off when you press the button
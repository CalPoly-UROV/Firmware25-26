## Week 1 Review
#### Registers

#### Bit Manipulation




## Week 2 Goal: Control the brightness of the LED via PWM

![[2.1.png]]
This is how we turn the LED on and off.
### Pulse Wave Modulation
To turn the LED on, we set the pin to high (3.3V). To turn it off, we set the pin low(0V). What if we turn the pin on and off super fast? 

![[2.2.png]]
If we go slow, toggling every 100ms or so, the LED is just blinking. We saw this in week 1. but what if we go faster? Eventually, the blinking smooths out into an apparent brightness change. However, subtle blinking persists until we go at a frequency higher than 2kHz, or toggling every 500us/0.5ms. 

This should reduce the apparent brightness by about 50% because the LED is on and off for an equal amount of time. Not sure if its exactly 50% due to physics and how our eyes perceive this, but we can say 50%. 

What if we want say, 25% brightness? Increasing the rate at which we toggle the pin (frequency) won't work because the average will still trend towards 50% of 3.3V. Instead we need to keep the LED off for longer than we have it on. 
![[2.3.png]]
In the above case, we should expect the brightness to be at 25%. This is equal to the "duty cycle" of the input. `duty cycle = pulse width/period` By changing the pulse width, we can change the duty cycle, and thus the brightness. This is Pulse Width Modulation.

##### But why?
PWM is used for a lot of things in in embedded systems. One big thing is that it can turn a binary signal into a sort of middle value. With GPIO, a pin can only be on (3.3V) or off (0V). With PWM, we can set a duty cycle of 50% and the average output voltage would be around 1.65V. And we can change the duty cycle to change this voltage.  
We use PWM to talk to the ROV thrusters and servo. They expect a non-binary voltage and translate that into motion. By changing the duty cycles, we can speed up the thrusters, slow them, etc.

### HAL_Delay()
We wrote a LED blink program last week. We were toggling the LED every 100ms or so with `HAL_Delay(100)` So we can just use `HAL_Delay()` to control timing right? No.
##### Innaccuracy
If we pass in values of 1ms to 5ms into `HAL_Delay()`, the function often doesn't actually wait an accurate amount of time. And we need to toggle faster than 1ms anyway.
##### Blocking
`HAL_Delay()` is a blocking function. This means that it essentially stops all computation and code execution while we wait. This is fine for simple programs, but when we are managing a bunch of sensors, we can't have the cpu waiting that often.

## The Timer Peripheral
![[2.4.png]]  
The timer peripheral consists of a lot of registers. We'll look at TIM2 in up-counting mode. 
#### Counter
All timers are built off of a single counter. When it receives a pulse, it adds 1 to itself.
![[2.5.png]]  
The TIM2 counter is 32 bits long so it can count up to 2^32. 

#### Capture Compare Register
This register holds a number. When the counter's value equals this, a capture-compare interrupt flag is fired. The interrupt will tell the code to go do something. More on this later.  

TIM2's CCRs are 32 bits long and there are 4 of them so they can check for different values and fire interrupts at different times.  
#### Auto-Reload Register
This is similar to a CCR in that it holds a value and compares it to the counter's value. But when the ARR's value is reaches, a different interrupt is fired and the counter's value is set back to 0.  

TIM2's ARR is 32 bits long.
#### Source Clock
The counter needs an input clock signal to work. This clock signal by default comes from a certain internal clock. Some timer modes allow for external clocks to drive the counter, but we won't use that right now. We can change the source clock via the IOC.
#### Prescaler
The prescaler divides the incoming clock signal into a lower frequency before they reach the counter.
![[2.6.png]]  
Its basically a smaller counter. It counts a certain number of pulses from the source clock and when it counts up to a certain number of them, it switches its output.

TIM2's prescaler can hold a 16 bit value. Because you can't divide by 0, it adds 1 to the value. So if you want to divide a frequency by 100, write 99 into the register.

## Task 1: Reading From Timer via Debugger
Goal : write a program that periodically reads from the counter  
#### Setting Timer up in IOC
![[2.7.png]]  
3 settings:   

| Setting                              | Value          |
| ------------------------------------ | -------------- |
| Clock Source                         | Internal Clock |
| Parameter Settings -> Counter Period | 1,000,000      |
| Parameter Settings -> Prescaler      | 15             |
Then save & generate code.
#### In main.c
In while loop:   
![[2.18.png]]  
We are storing the timer count into last_val every 100ms. We subtract the current count from the last count to find the difference. We'll test to see how accurate `HAL_Delay()` is.

val and last_val must be a `uint32_t` This is an unsigned integer that is 32 bits long.


#### Running in Debug Mode

Run in debug mode  
![[2.9.png]]  
Run for a bit then suspend.
![[2.16.png]]
Use SFR to check timer count register
![[2.17.png]]
And we can check value of variables by stepping back out to the while loop
![[2.19.png]]

If clock source is 16 MHz and we have 15 in the prescaler, what should the counter be at after every loop?  
	1 KHz frequency -> 1 ms period
	1 MHz frequency -> 1 us period


## Task 2: Delay Function with Interrupts
Lets write our own version of HAL_Delay, but with the ability to wait for microseconds instead of just milliseconds. We'll write it as a separate c file so its more portable.

##### Enabling Timer Interrupts
In TIM2 set these:

| Setting                              | Value                                        |
| ------------------------------------ | -------------------------------------------- |
| NVIC Settings                        | TIM2 global interrupt on                     |
| Parameter Settings -> Counter Period | The value at which to reset & fire interrupt |
Save & generate code

##### In `stm32f4xx_it.c`  
![[2.23.png]]  
This is the function that is called when the timer resets. It searches specifically for this function name. We can delete this and we'll write the handler in our new `delay.c` file so everything is together. This is regenerated each time we generate code, so you have to come here and delete this every time.
##### Creating a new c file
In Src folder, create a new source file called `delay.c` 
![[2.24.png]]

##### Header files
In Inc folder, create a new header file called `delay.h` Header files are used to link source files together while compiling. `#include` tells the compiler to add a certain file to its scope so that it can reference functions, global variables, macros, etc. 
![[2.25.png]]

##### In `main.c`
Now we can test this out. Toggle the LED like we did last week, but use delay instead of HAL_Delay. Pick a frequency low enough that we can see the LED turn on and off. 
## Task 3: Single LED Brightness Controller
1. Step that frequency higher and higher until the human eye can no longer detect that its blinking, but instead it looks like the brightness is lower than normal.   
2. Try to change the pulse width: have the LED on for a different amount of time than it is off. This should change the brightness
3. Write code that utilizes the user button. Have it control the brightness of the LED when pressed. Make at least 3 different levels of brightness available.

![[2.26.png]]

We've done PWM! We solved the inaccuracy of HAL_Delay, but we still have an issue that we are blocking all other code execution while waiting. We can use interrupts in a smarter way to get around this.

## Task 4: Interrupt-Based LED Brightness Driver
Goal: Write a function, `LED_Brightness(uint32_t brightness)` This function takes in a number from 0 to 100 inclusive, and sets the LED to that percent brightness.  
When we call this function in `main.c`, execution should continue like normal afterwards and we shouldn't have to manage anything else about the LED in `main.c` 

## FILL OUT DOCUMENTATION FORM